# -*- coding: utf-8 -*-
"""Backend Challenge .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HNKAWdbuWzy0bAe-Ob-FtgGWByGLC0F8

# **DESAFÍO BACKEND**

En Houm estamos buscando personas que sean capaces de construir soluciones de calidad, enfocadas en atributos como escalabilidad y mantenibilidad. Houm es una startup que busca transformar la forma en que se arriendan propiedades. Nos encargamos de buscar los inquilinos indicados para cada propiedad y además, de administrarlas. Para lograr esto, nos apoyamos fuertemente en la tecnología. Para ofrecer el mejor servicio, debemos saber la información del mercado en el que nos encontramos inmersos. Esto, en la mayoría de los casos, se logra gracias a integraciones con servicios externos y que a veces significan grandes desafíos. Dicho esto, el desafío que deberás completar consta de ciertas preguntas que necesitas responder escribiendo código Python. 

---

## **Requerimientos**

* Para responder las preguntas deberás hacer uso de la PokéAPI (https://pokeapi.co/).
* Cada pregunta debe ser respondida entregando una función Python, que luego de ser ejecutada debe entregar la respuesta exacta a la pregunta.

* Asegúrate de incluir librerías que hayas utilizado en el archivo de requerimientos del proyecto y agregar los “imports” necesarios.

* Es importante que todos los procesos que escribas sean lo más eficientes posible y que el código sea calidad de producción. Muestranos todos tus conocimientos de Python y de buenas prácticas de Software.

# **Librerias utilizadas**
"""

import requests
import re

"""# **Declarando funciones y mensajes globales**"""

connectionMessageError = "Ha ocurrido un error inesperado en el sistema, por favor intente más tarde\n"
successfulMessage = "¡Ejecución finalizada!, muchas gracias por su consulta\n"
invalidOption = "La opción digitada no es valida, intente nuevamente\n"

def optionForUser():
 
    estatus = False

    while not estatus:
      
        try:
            support = input("¿Desea saber la sustentación de la respuesta? [S/N]: ").lower()
            estatus=True
            print()
        except:
            print('Error, la opción ingresada no puede ser procesada, por favor intente nuevamente\n')
     
    return support

"""# **Pregunta #1**

**1.** Obtén cuantos pokemones poseen en sus nombres “at” y tienen 2 “a” en su nombre, incluyendo la primera del “at”. Tu respuesta debe ser un número.

# **RESPUESTA #1**
"""

pokedex = []

limit = '2000'
offset = '0'

def getPokemons(url = "https://pokeapi.co/api/v2/pokemon/?limit=" + limit + "&offset=" + offset):
  
  response = requests.get(url)

  if response.status_code == 200:
    payload = response.json()
    results = payload.get('results', [])
    if results:
      for pokemon in results:
        name = pokemon['name'].lower()
        if name not in pokedex:
          pokedex.append(name)
  else:
    print(connectionMessageError)

getPokemons()

numbreOfPokemon = len(pokedex)

r = re.compile("(.*at.*a+)|(.*a+.*at)")
filteredList = list(filter(r.match, pokedex))

answerOne = len(filteredList)

print('+--------------------------------------------------------------------------------------------------------------------------------------------+')
print(f'|La respuesta a la pregunta de cuantos pokémons poseen en sus nombres “at” y tienen 2 “a” en su nombre, incluyendo la primera del “at” es: {answerOne}|')
print('+--------------------------------------------------------------------------------------------------------------------------------------------+\n')

exit = False

while not exit:

    selection = optionForUser()

    if selection == 's':
      print(f'Existen un total actual de {numbreOfPokemon} pokémons incluidas sus formas regionales, variaciones, forma gigamax y mega-evoluciones\n')
      print(f'Estos son: {pokedex} \n')
      print(f'Y los {answerOne} Pokémons que cumplen con el criterio de aceptación son: {filteredList}\n')
      exit = True
    elif selection == 'n':
      exit = True
    else:
        print(invalidOption)

print(successfulMessage)

"""# **Pregunta #2**

**2.** ¿Con cuántas especies de pokémon puede procrear raichu? (2 Pokémon pueden procrear si están dentro del mismo egg group). Tu respuesta debe ser un número. Recuerda eliminar los duplicados.

# **RESPUESTA #2**
"""

eggRaichu = []

namePokemon = 'raichu'

def getEggGroup(url = "https://pokeapi.co/api/v2/pokemon-species/" + namePokemon):
  
  response = requests.get(url)

  if response.status_code == 200:
    payload = response.json()
    results = payload.get('egg_groups', [])
    if results:
      for eggGroups in results:
        name = eggGroups['name'].lower()
        if name not in eggRaichu:
          eggRaichu.append(name)
  else:
    print(connectionMessageError)

speciesEggRaichu = []

def getSpecies():

  iteration = 0

  for pokemonSpecies in eggRaichu:
    
      response = requests.get("https://pokeapi.co/api/v2/egg-group/" + eggRaichu[iteration])

      if response.status_code == 200:
        payload = response.json()
        results = payload.get('pokemon_species', [])
        if results:
            for pokemonSpecies in results:
              name = pokemonSpecies['name'].lower()
              if name not in speciesEggRaichu:
                speciesEggRaichu.append(name)
            iteration += 1
      else:
        print(connectionMessageError)

speciesEggGround = []

speciesEggFairy = []

def getSpeciesGroundFairy():

  for pokemonSpecies in eggRaichu:
    
      response = requests.get("https://pokeapi.co/api/v2/egg-group/" + eggRaichu[0])

      if response.status_code == 200:
        payload = response.json()
        results = payload.get('pokemon_species', [])
        if results:
            for pokemonSpecies in results:
              name = pokemonSpecies['name'].lower()
              if name not in speciesEggGround:
                speciesEggGround.append(name)
      else:
        print(connectionMessageError)

      response = requests.get("https://pokeapi.co/api/v2/egg-group/" + eggRaichu[1])

      if response.status_code == 200:
        payload = response.json()
        results = payload.get('pokemon_species', [])
        if results:
            for pokemonSpecies in results:
              name = pokemonSpecies['name'].lower()
              if name not in speciesEggFairy:
                speciesEggFairy.append(name)
      else:
        print(connectionMessageError)

getEggGroup()

getSpecies()

getSpeciesGroundFairy()

answerTwo = len(speciesEggRaichu)

summatory = len(speciesEggGround) + len(speciesEggFairy)

duplicatePokemon = set(speciesEggGround) & set(speciesEggFairy)

print('+---------------------------------------------------------------------------------------+')
print(f'|La respuesta a la pregunta de cuántas especies de pokémon puede procrear raichu es: {answerTwo}|')
print('+---------------------------------------------------------------------------------------+\n')

exit = False

while not exit:

    selection = optionForUser()

    if selection == 's':
      print(f'Raichu puede procrear con los egg group {eggRaichu}\n')
      print(f'De las cuales la {eggRaichu[0]} tiene en total {len(speciesEggGround)} especies de pokémons, los cuales son los siguientes: {speciesEggGround}\n')
      print(f'De las cuales la {eggRaichu[1]} tiene en total {len(speciesEggFairy)} especies de pokémons, los cuales son los siguientes: {speciesEggFairy}\n')
      print(f'Al sumar los {len(speciesEggGround)} del grupo {eggRaichu[0]} con los {len(speciesEggFairy)} del grupo {eggRaichu[1]} se obtiene como resultado un total de {summatory}, y si le restamos las {len(duplicatePokemon)} especies de pokémon duplicadas que son: {duplicatePokemon}, terminamos por obtener como resultado {answerTwo}\n')
      exit = True
    elif selection == 'n':
      exit = True
    else:
        print(invalidOption)

print(successfulMessage)

"""# **Pregunta #3**

**3.** Entrega el máximo y mínimo peso de los pokémon de tipo fighting de primera generación (cuyo id sea menor o igual a 151). Tu respuesta debe ser una lista con el siguiente formato: [1234, 12], en donde 1234 corresponde al máximo peso y 12 al mínimo.

# **RESPUESTA #3**
"""

pokedexFighting = []

pokedexFirstGeneration = []

pokedexFirstGenerationFighting = []

weightFirstGenerationFightingPokemon = []

weightRangeFightingPokemon = []

limit = '151'
offset = '0'

def getPokemonsFighting():
  
  response = requests.get("https://pokeapi.co/api/v2/type/fighting/")

  if response.status_code == 200:
    payload = response.json()
    results = payload.get('pokemon', [])
    if results:
      for pokemon in results:
        name = pokemon['pokemon']['name']
        if name not in pokedexFighting:
          pokedexFighting.append(name)
  else:
    print(connectionMessageError)
  
  response = requests.get("https://pokeapi.co/api/v2/pokemon/?limit=" + limit + "&offset=" + offset)

  if response.status_code == 200:
    payload = response.json()
    results = payload.get('results', [])
    if results:
      for pokemon in results:
        name = pokemon['name'].lower()
        if name not in pokedexFirstGeneration:
          pokedexFirstGeneration.append(name)
  else:
    print(connectionMessageError)

  for pokemon in pokedexFighting:
    if (pokemon not in pokedexFirstGenerationFighting) and (pokemon in pokedexFirstGeneration):
        pokedexFirstGenerationFighting.append(pokemon)

  index = 0

  for pokemon in pokedexFirstGenerationFighting:

    response = requests.get("https://pokeapi.co/api/v2/pokemon/" + pokedexFirstGenerationFighting[index])

    if response.status_code == 200:
      payload = response.json()
      weight = payload.get('weight', [])
      if weight not in weightFirstGenerationFightingPokemon:
        weightFirstGenerationFightingPokemon.append(weight)
      index += 1
    else:
      print(connectionMessageError)

  weightMax = max(weightFirstGenerationFightingPokemon)

  weightMin = min(weightFirstGenerationFightingPokemon)

  if weightMax not in weightRangeFightingPokemon:
    weightRangeFightingPokemon.append(weightMax)
  if weightMin not in weightRangeFightingPokemon: 
    weightRangeFightingPokemon.append(weightMin)

def showNameAndWeight():

  index = 0

  for pokemon in pokedexFirstGenerationFighting:
    print(f"{pokedexFirstGenerationFighting[index].capitalize()}: {weightFirstGenerationFightingPokemon[index]}")
    index += 1

getPokemonsFighting()

answerthree = weightRangeFightingPokemon

index = 0

print('+------------------------------------------------------------------------------------------------------------------------------------------+')
print(f'|La respuesta a la pregunta de cuanto es el peso máximo y mínimo peso de los pokémon de tipo fighting de primera generación es: {answerthree}|')
print('+------------------------------------------------------------------------------------------------------------------------------------------+\n')

exit = False

while not exit:

    selection = optionForUser()

    if selection == 's':
      print(f'Exiten actualmente {len(pokedexFighting)} pokémons de tipo lucha, de los cuales solo {len(pokedexFirstGenerationFighting)} pertenecen a la primera generación y estos son los siguientes: {pokedexFirstGenerationFighting}\n')
      print("Y los pesos de cada pokémon de tipo lucha se muestra a continuación:\n")
      showNameAndWeight()
      print()
      exit = True
    elif selection == 'n':
      exit = True
    else:
        print(invalidOption)

print(successfulMessage)
